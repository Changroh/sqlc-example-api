// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: appointments.sql

package repo

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAppointment = `-- name: CreateAppointment :one
INSERT INTO appointments (patient_id, doctor_id, time_slot, status, notes)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, patient_id, doctor_id, time_slot, status, notes, created_at, updated_at
`

type CreateAppointmentParams struct {
	PatientID uuid.UUID `json:"patient_id"`
	DoctorID  uuid.UUID `json:"doctor_id"`
	TimeSlot  time.Time `json:"time_slot"`
	Status    string    `json:"status"`
	Notes     string    `json:"notes"`
}

func (q *Queries) CreateAppointment(ctx context.Context, arg CreateAppointmentParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, createAppointment,
		arg.PatientID,
		arg.DoctorID,
		arg.TimeSlot,
		arg.Status,
		arg.Notes,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.DoctorID,
		&i.TimeSlot,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDoctorScheduleBySpecialty = `-- name: GetDoctorScheduleBySpecialty :many
SELECT a.id, a.patient_id, a.doctor_id, a.time_slot, a.status, a.notes, a.created_at, a.updated_at
FROM appointments a
JOIN doctors d ON a.doctor_id = d.id
WHERE d.specialty = $1
  AND ($2::timestamptz IS NULL OR a.time_slot >= $2)
  AND ($3::timestamptz IS NULL OR a.time_slot <= $3)
ORDER BY a.time_slot ASC
`

type GetDoctorScheduleBySpecialtyParams struct {
	Specialty string             `json:"specialty"`
	FromTs    pgtype.Timestamptz `json:"from_ts"`
	ToTs      pgtype.Timestamptz `json:"to_ts"`
}

func (q *Queries) GetDoctorScheduleBySpecialty(ctx context.Context, arg GetDoctorScheduleBySpecialtyParams) ([]Appointment, error) {
	rows, err := q.db.Query(ctx, getDoctorScheduleBySpecialty, arg.Specialty, arg.FromTs, arg.ToTs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Appointment{}
	for rows.Next() {
		var i Appointment
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.DoctorID,
			&i.TimeSlot,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPatientAppointments = `-- name: GetPatientAppointments :many
SELECT id, patient_id, doctor_id, time_slot, status, notes, created_at, updated_at
FROM appointments
WHERE patient_id = $1
  AND ($2::timestamptz IS NULL OR time_slot >= $2)
  AND ($3::timestamptz IS NULL OR time_slot <= $3)
  AND ($4::text IS NULL OR status = $4)
ORDER BY time_slot ASC
LIMIT COALESCE(NULLIF($6, 0), 50)
OFFSET COALESCE($5, 0)
`

type GetPatientAppointmentsParams struct {
	PatientID  uuid.UUID          `json:"patient_id"`
	FromTs     pgtype.Timestamptz `json:"from_ts"`
	ToTs       pgtype.Timestamptz `json:"to_ts"`
	Status     string             `json:"status"`
	OffsetRows interface{}        `json:"offset_rows"`
	LimitRows  interface{}        `json:"limit_rows"`
}

func (q *Queries) GetPatientAppointments(ctx context.Context, arg GetPatientAppointmentsParams) ([]Appointment, error) {
	rows, err := q.db.Query(ctx, getPatientAppointments,
		arg.PatientID,
		arg.FromTs,
		arg.ToTs,
		arg.Status,
		arg.OffsetRows,
		arg.LimitRows,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Appointment{}
	for rows.Next() {
		var i Appointment
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.DoctorID,
			&i.TimeSlot,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAppointmentStatus = `-- name: UpdateAppointmentStatus :one
UPDATE appointments
SET status = $2,
    updated_at = now()
WHERE id = $1
RETURNING id, patient_id, doctor_id, time_slot, status, notes, created_at, updated_at
`

type UpdateAppointmentStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateAppointmentStatus(ctx context.Context, arg UpdateAppointmentStatusParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, updateAppointmentStatus, arg.ID, arg.Status)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.DoctorID,
		&i.TimeSlot,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
